<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GAME</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+1p:wght@100;300;500;700;800&family=Quicksand:wght@300;400&family=Raleway:ital,wght@0,100;0,200;0,300;0,400;0,500;1,100;1,200;1,300;1,400;1,500&display=swap" rel="stylesheet">
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0/jquery.min.js"></script>
    <script type="text/javascript" src="fly.js"></script>
    

    
</head>
<body>
    <div class="main">
        <div class=play_left">
            <div class="container">
                <div class="title">
                    <p style="font-family:Jelantik"   class="animate_animated animate__backInLeft"  id="weirdtext">Welcome to</p>

                    <p style="font-family: Jelantik" class="animate__animated animate__bounceInDown" id="largeText">Memoryify</p>
                </div>

				<div class="input">
					
					<input id="txt" onInput = "getValue()"  type="text" id="firstname"    style="color:#e75480" placeholder="Type your name please..." maxlength="15"/><br>
				</div>
				<div id="enjoy">and enjoy playing,</div>
				<div id = "result"></div>
            </div>


         <div class="buttons">
                <button value="PLAY" onclick="play(), mute(), change()" class="bubbly-button">
                    <span class="tooltip">Mute</span>
                    <audio id="audio" src="sounds_and_music/twinkles_cutted.mp3"></audio>
                    <i class="fa-solid fa-volume-xmark fa-bounce fa-2xl"></i>
                    <!--<i class="fa-solid fa-music fa-bounce fa-2xl" id="img2" onClick="chg(this.id)" style="color: #fefcdd; display:none"></i>-->
                </button>
                <button value="PLAY"  onclick="play(), changeCoordinates(), validateName()", class="bubbly-button">
                    <!--<input type="button" value="PLAY" onclick="play()" class="bubbly-button">-->
                        <span class="tooltip">Play</span>
                        <audio id="audio" src="sounds_and_music/twinkles_cutted.mp3"></audio>
                        <i class="fa-solid fa-face-smile fa-bounce fa-2xl"></i>
                        <!--<i class="fa-solid fa-house fa-bounce fa-2xl" style="color: #f2f7b7;"></i>-->
                </button>
                <button value="PLAY" onclick="play(), changeDayToNight()" class="bubbly-button" >
                    <span class="tooltip">Night</span>
                    <audio id="audio" src="sounds_and_music/twinkles_cutted.mp3"></audio>
                    <i class="fa-solid fa-moon fa-bounce fa-2xl"></i>
                    <!--<<i class="fa-solid fa-sun fa-bounce fa-2xl" style="color: #f8fadb;"></i>"></i>-->
                </button>
              
                <button value="PLAY" onclick="play()" class="bubbly-button" id="scoreBtn">
                    <span class="tooltip">Scores</span>
                    <audio id="audio" src="sounds_and_music/twinkles_cutted.mp3"></audio>
                    <i class="fa-solid fa-star fa-bounce fa-2xl"></i>
                    <!--<<i class="fa-solid fa-sun fa-bounce fa-2xl" style="color: #f8fadb;"></i>"></i>-->
                    </button>
                

                <button value="PLAY" onclick="play()" class="bubbly-button" id="myBtn">
                    <span class="tooltip">Info</span>
                    <audio id="audio" src="sounds_and_music/twinkles_cutted.mp3"></audio>
                    <i class="fa-solid fa-info fa-bounce fa-2xl"></i>
                    <a href="#ex1" rel="modal:open"></a>
                    <!--<<i class="fa-solid fa-sun fa-bounce fa-2xl" style="color: #f8fadb;"></i>"></i>-->
                </button>
            </div>
            <div id="myModal" class="modal">
                <div class="modal-content">
                    <div class="modal-body">
                        <span class="close">&times;</span>
                        <p style="font-family: Quicksand;" class="info">Hi Friend!!!<br>
                                                    So here is some info for you to read before you start your journey with <span style="font-family:'Jelantik'">Memoryify</span>.
                                                    This game was created to test your ability to retain information. Play it to improve your 
                                                    attention, concentration, and focus. The idea is to find all 8 pairs of images as fast as your memory will allow you!
													So lets check how fast you can make it. Remember that you may restart the game any time.
													To begin please enter your name and click on smily button. Hope you'll enjoy it!<br>
                        </p>
                    </div>
                </div>
            </div>
        

            <div id="myModal2" class="modal2">
                <div class="modal-content2">
                <div class="modal-body2">
                    <span class="close2">&times;</span>
                        <table class="zigzag" style="border-collapse:separate; border-spacing:.25em 1em;transform:rotate(6deg); border:beige 2px solid; border-radius:5px">
                            <thead>
                                <tr style="background-color: darkgray;transform:rotate(2deg); border-radius: 5px; font-family: 'Jelantik';">
                                    <th class="header" style="width:70%"; border-radius: 5px;>Player</th>
                                    <th class="header" style="width:10%">Moves</th>
                                    <th class="header" style="width:20%">Time</th>
                                    
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="background-color: lightgrey;transform:rotate(-2deg); border-radius: 20px;">
                                    <td>aaaa</td>
                                    <td>bbbb</td>
                                    <td>cccc</td>
                                    
                                </tr>
                                <tr  style="background-color: lightgrey;transform:rotate(2deg)">
                                    <td>aaa</td>
                                    <td>bbb</td>
                                    <td>ccc</td>
                                </tr>
                                <tr  style="background-color: lightgrey;transform:rotate(-2deg)">
                                    <td>aaa</td>
                                    <td>bbb</td>
                                    <td>ccc</td>
                                </tr>
                                <tr style="background-color: lightgrey;transform:rotate(2deg)">
                                    <td>aaa</td>
                                    <td>bbb</td>
                                    <td>ccc</td>
                                </tr>
                                <tr style="background-color: lightgrey;transform:rotate(-2deg)">
                                    <td>aaa</td>
                                    <td>bbb</td>
                                    <td>ccc</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>



            <audio id="background_audio" autoplay="autoplay" loop>
                <source src="sounds_and_music/sonic-wave-134902.mp3"/>
            </audio>
        </div><!--the end of play_left page-->
        <div class="play_right" id="right" style="display:none;">
            <div class="container2">
               
            
                <section class="score-panel">
                  
                    <ul id="star-rating" class="star-rating">
                        <li class="star"><i class="fa fa-star"></i></li>
                        <li class="star"><i class="fa fa-star"></i></li>
                        <li class="star"><i class="fa fa-star"></i></li>
                    </ul>
                    <span class="moves-counter">0</span><span class="moves">Moves</span> 
                    <div class="timer-container">
                        <span class="timer"><i class="fa fa-hourglass-start"></i> Timer: 00:00</span>
                    </div>
                    <div class="reset">
                        <button class="btn reset-btn" style="width:100px; height:30px">Reset<i class="fa fa-repeat"></i></button>
                    </div>
                </section>
            
                <!-- Modal -->
                <section class="win-game-modal">
                    <div id="modalgame" class="modalgame">
                        <!-- Modal content -->
                        <div class="modalgamecontent">
                            <span class="close">&times;</span>
                            <h2>Congratulations!</h2>
                            <p>You have won the game and found all 8 pairs of cards.</p>
                            <img class="modal-img" src="icons/shooting_star.png" alt="stars">
                            <button class="btn play-again-btn">Play Again?</button>
                        </div>
                    </div>
                </section>
            
                <ul class="deck"></ul>
            </div>
            
        </div>
    </div>
    <script type="text/javascript" src="fly.js"></script>
   
    <script>
        
        
		

        let modal = document.getElementById("myModal");
        let btn = document.getElementById("myBtn");
        let span = document.getElementsByClassName("close")[0];
        btn.onclick = function() {
        modal.style.display = "block";
        }
        span.onclick = function() {
        modal.style.display = "none";
        }
        window.onclick = function(event) {
        if (event.target == modal) {
            modal.style.display = "none";
            }
        }

        let modal2 = document.getElementById("myModal2");
        let btn2 = document.getElementById("scoreBtn");
        let span2 = document.getElementsByClassName("close2")[0];
        btn2.onclick = function() {
        modal2.style.display = "block";
        }

        span2.onclick = function() {
        modal2.style.display = "none";
        }
         window.onclick = function(event2) {
        if (event2.target == modal2) {
            modal2.style.display = "none";
            }
        }

        
        function change(){
            const musicOn = document.getElementsByTagName("i");
            const toolTips = document.querySelectorAll("span")
            if(musicOn[0].getAttribute("class")=== "fa-solid fa-volume-xmark fa-bounce fa-2xl" ){
                musicOn[0].removeAttribute("class");
                musicOn[0].setAttribute("class", "fa-solid fa-music fa-bounce fa-2xl");
                toolTips[0].innerHTML = "SoundOn"
            } else {
                musicOn[0].removeAttribute("class");
                musicOn[0].setAttribute("class", "fa-solid fa-volume-xmark fa-bounce fa-2xl")
                toolTips[0].innerHTML = "Mute"
            }
        };
        

		function getValue(){
					let txt = document.getElementById("txt");
					let textValue = txt.value;

					let result =document.getElementById("result");
					result.innerText = textValue

   				 }
        
        //valid
		function validateName() {
    		let x = document.getElementById("txt").value;
			if (x == "") {
				alert("First Name is required!");
				return false;
			}
			return ;
	}


        function changeCoordinates(){
            const smiley = document.getElementsByTagName("i");
            const toolTips = document.querySelectorAll("span");
            const buttonToREmove = document.querySelectorAll("button");
            const mainDiv = document.getElementsByClassName("main");
            let myBlock = document.getElementById("right");
			
            if(smiley[1].getAttribute("class")==="fa-solid fa-face-smile fa-bounce fa-2xl"){
                smiley[1].removeAttribute("class");
                smiley[1].setAttribute("class", "fa-solid fa-house fa-bounce fa-2xl");
                document.querySelector(".container").style.marginBottom = "50px"
                document.querySelector(".container").style.textAlign = "left";
                
                document.querySelector(".container").style.marginLeft = "-20px";
                document.querySelector(".container").style.marginTop = "20px";
                document.querySelector("#weirdtext").style.fontSize = "130px";
                document.querySelector("#largeText").style.fontSize = "140px";
                document.querySelector(".buttons").style.justifyContent= "left";
				document.querySelector(".buttons").style.marginLeft = "-10px";
                buttonToREmove[3].style.visibility = "hidden";
                buttonToREmove[4].style.visibility = "hidden"
                toolTips[1].innerHTML="Home";
                myBlock.style.display = "block";
                document.querySelector(".main").style.flexDirection="row";
                document.querySelector(".main").style.justifyContent = "space-evenly";
                document.querySelector(".main").style.marginTop = "20px";
				document.querySelector(".input").style.display = "none"
				document.querySelector("#result").style.display = "block";
				document.querySelector("#result").style.color = "#F04A00";
				document.querySelector("#result").style.fontFamily = "Jelantik";
				document.querySelector("#result").style.fontSize = "140px";
				document.querySelector("#result").style.textShadow = "2px 20px 25px lightyellow";
				document.querySelector("#result").style.opacity = "0.9"
				document.querySelector("#enjoy").style.display = "block";
				document.querySelector("#enjoy").style.color = "#F04A00";
				document.querySelector("#enjoy").style.fontFamily = "Jelantik";
				document.querySelector("#enjoy").style.fontSize = "140px";
				document.querySelector("#enjoy").style.textShadow = "2px 20px 25px lightyellow";
				document.querySelector("#enjoy").style.opacity = "0.9";
				document.querySelector("#enjoy").style.marginTop = "-35px";
				
            }else{
                smiley[1].removeAttribute("class");
                smiley[1].setAttribute("class", "fa-solid fa-face-smile fa-bounce fa-2xl");
                document.querySelector(".container").style.justifyContent = "center";
                document.querySelector(".container").style.textAlign = "center";
                document.querySelector(".buttons").style.justifyContent= "center";
                document.querySelector("#weirdtext").style.fontSize = "200px";
                document.querySelector("#largeText").style.fontSize = "240px";
                document.querySelector(".container").style.marginTop = "140px"
                toolTips[1].innerHTML="Play";
                buttonToREmove[3].style.visibility = "visible";
                buttonToREmove[4].style.visibility = "visible";
                myBlock.style.display = "none";
                document.querySelector(".input").style.display = "block"
				document.querySelector("#result").style.display = "none";
				document.querySelector("#enjoy").style.display = "none";
            }

        }

        function changeDayToNight(){
            const dayOrNight = document.getElementsByTagName("i");
            const toolTips = document.querySelectorAll("span")

            if(dayOrNight[2].getAttribute("class")=== "fa-solid fa-moon fa-bounce fa-2xl"){
                dayOrNight[2].removeAttribute("class");
                dayOrNight[2].setAttribute("class", "fa-solid fa-sun fa-bounce fa-2xl")
                document.querySelector("body").style.backgroundImage ="url(images/night.jpg)";
                document.querySelector("p").style.color="#ffd8f7";
                document.querySelector("p").style.textShadow="2px 20px 25px #f0799d";
                document.querySelector("#largeText").style.color="#ffd8f7";
                document.querySelector("#largeText").style.textShadow="2px 20px 25px #f0799d";
                document.querySelector("#result").style.color = "#ffd8f7";
				document.querySelector("#enjoy").style.color="#ffd8f7";
				
                toolTips[2].innerHTML = "Light"
                
            } else {
                dayOrNight[2].removeAttribute("class");
                dayOrNight[2].setAttribute("class", "fa-solid fa-moon fa-bounce fa-2xl");
                document.querySelector("body").style.backgroundImage = "url(images/gradient-forest-landscape.jpg.avif)";
                document.querySelector("p").style.color="#F04A00";
                document.querySelector("p").style.textShadow="2px 20px 25px lightyellow";
                document.querySelector("#largeText").style.color="#F04A00";
                document.querySelector("#largeText").style.textShadow="2px 20px 25px lightyellow";
                document.querySelector("#result").style.color = "#F04A00";
                document.querySelector("#enjoy").style.color="#F04A00"

                toolTips[2].innerHTML = "Dark"
            }
        };

        function play() {
         let audio = document.getElementById("audio");
            audio.play();
        };
        

        function mute(){
              if(document.getElementById('background_audio').muted == false){

                document.getElementById('background_audio').muted = true;
                
              } else {
                document.getElementById('background_audio').muted = false;
               
        }
    }


    let animateButton = function(e) {
        e.preventDefault;
        e.target.classList.remove('animate');
        e.target.classList.add('animate');
        setTimeout(function(){
        e.target.classList.remove('animate');
        },700);
    };

    let bubblyButtons = document.getElementsByClassName("bubbly-button");

    for (let i = 0; i < bubblyButtons.length; i++) {
        bubblyButtons[i].addEventListener('click', animateButton, false);
    }



// Array of Deck of Card Images
const deckCards = ["icons/bird.png", "icons/bird.png", "icons/flower.png", "icons/flower.png", "icons/forest.png", "icons/forest.png", "icons/hamster.png", "icons/hamster.png", "icons/sunny.png", "icons/sunny.png", "icons/heart.png", "icons/heart.png", "icons/bear.png", "icons/bear.png", "icons/butterfly.png", "icons/butterfly.png"];

// Global Arrays
// Access the <ul> with class of .deck
const deck = document.querySelector(".deck");
// Create an empty array to store the opened cards
let opened = [];
// Create an empty array to store the matched cards
let matched = [];

// Access the modal
const modalgame = document.getElementById("modalgame");

// Access the reset button
const reset = document.querySelector(".reset-btn");
// Access the play again button
const playAgain = document.querySelector(".play-again-btn");

// Select the class moves-counter and change it's HTML  
const movesCount = document.querySelector(".moves-counter");
// Create variable for moves counter, start the count at zero
let moves = 0;

// Access the <ul> element for the star rating section and then the <li> elements within it
const star = document.getElementById("star-rating").querySelectorAll(".star");
// Variable to keep track of how many stars are left
let starCount = 3;

// Get the span tag for the timer.
const timeCounter = document.querySelector(".timer");
// To use this variable to stop the time started in timer
let time;
// Create variables for time count, start all at zero
let minutes = 0;
let seconds = 0;
// For use in the click card event listener
let timeStart = false;

// Shuffle function from http://stackoverflow.com/a/2450976
function shuffle(array) {
  let currentIndex = array.length, temporaryValue, randomIndex;

  while (currentIndex !== 0) {
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex -= 1;
      temporaryValue = array[currentIndex];
      array[currentIndex] = array[randomIndex];
      array[randomIndex] = temporaryValue;
  }
  return array;
}

/*
Start Game: Shuffle the deck, create <li> tags and <img> 
tags and append to the deck <ul> with the new shuffled content
*/
function startGame() {
	// Invoke shuffle function and store in variable
	const shuffledDeck = shuffle(deckCards); 
	// Iterate over deck of cards array
	for (let i = 0; i < shuffledDeck.length; i++) {
		// Create the <li> tags
		const liTag = document.createElement('LI');
		// Give <li> class of card
		liTag.classList.add('card');
		// Create the <img> tags
		const addImage = document.createElement("IMG");
		// Append <img> to <li>
		liTag.appendChild(addImage);
		// Set the img src path with the shuffled deck
		addImage.setAttribute("src",shuffledDeck[i] + "?raw=true");
		// Add an alt tag to the image
		addImage.setAttribute("alt", "random pictures");
		// Update the new <li> to the deck <ul>
		deck.appendChild(liTag);
	}
}

startGame();

/*
Remove all child nodes from the deck <li> tags and
<img> tags.  To be called in set everything function only
*/
function removeCard() {
	// As long as <ul> deck has a child node, remove it
	while (deck.hasChildNodes()) {
		deck.removeChild(deck.firstChild);
	}
}

/*
Update the timer in the HTML for minutes and seconds
This timer() function is invoked in the event listener
on the first card click
Used: https://www.w3schools.com/js/js_timing.asp
*/
function timer() {
	// Update the count every 1 second
	time = setInterval(function() {
		seconds++;
			if (seconds === 60) {
				minutes++;
				seconds = 0;
			}
		// Update the timer in HTML with the time it takes the user to play the game
		timeCounter.innerHTML = "<i class='fa fa-hourglass-start'></i>" + " Timer: " + minutes + " Mins " + seconds + " Secs" ;
	}, 1000);
}

/*
Stop the timer once the user has matched
all 16 cards, total of 8 pairs
Used: https://www.w3schools.com/js/js_timing.asp
*/
function stopTime() {
	clearInterval(time);
}

/*
Reset all global variables and the content of HTML elements
timer, stars, moves, and the moves and timer inner HTML
*/
function resetEverything() {
	// Stop time, reset the minutes and seconds update the time inner HTML
	stopTime();
	timeStart = false;
	seconds = 0;
	minutes = 0;
	timeCounter.innerHTML = "<i class='fa fa-hourglass-start'></i>" + " Timer: 00:00";
	// Reset star count and the add the class back to show stars again
	star[1].firstElementChild.classList.add("fa-star");
	star[2].firstElementChild.classList.add("fa-star");
	starCount = 3;
	// Reset moves count and reset its inner HTML
	moves = 0;
	movesCount.innerHTML = 0;
	// Clear both arrays that hold the opened and matched cards
	matched = [];
	opened = [];
	// Clear the deck
	removeCard();
	// Create a new deck
	startGame();
}

/*
Increment the moves counter.  To be called at each
comparison for every two cards compared add one to the count
*/
function movesCounter() {
	// Update the html for the moves counter
	movesCount.innerHTML ++;
	// Keep track of the number of moves for every pair checked
	moves ++;
}

/*
Update the star rating.  Depending on the number of
moves the user completes the game, the stars will decrease
with the more moves the user takes.
*/
function starRating() {
	if (moves === 14) {
		// First element child is the <i> within the <li>
		star[2].firstElementChild.classList.remove("fa-star");
		starCount--;
	}
	if (moves === 18) {
		star[1].firstElementChild.classList.remove("fa-star");
		starCount--;
	}
}

/*
Compare two cards to see if they match or not
*/
function compareTwo() {
	// When there are 2 cards in the opened array
	if (opened.length === 2) {
  		// Disable any further mouse clicks on other cards
  		document.body.style.pointerEvents = "none";
  }
	// Compare the two images src
	if (opened.length === 2 && opened[0].src === opened[1].src) {
		// If matched call match()
		match();
		// console.log("It's a Match!");
	} else if (opened.length === 2 && opened[0].src != opened[1].src) {
		// If No match call noMatch()
		noMatch();
		// console.log("NO Match!");
	}
}

/*
If the two cards match, keep the cards open and
apply class of match
*/ 
function match() {
	/* Access the two cards in opened array and add
	the class of match to the imgages parent: the <li> tag
	*/
	setTimeout(function() {
		opened[0].parentElement.classList.add("match");
		opened[1].parentElement.classList.add("match");
		// Push the matched cards to the matched array
		matched.push(...opened);
		// Allow for further mouse clicks on cards
		document.body.style.pointerEvents = "auto";
		// Check to see if the game has been won with all 8 pairs
		winGame();
		// Clear the opened array
		opened = [];
	}, 600);
	// Call movesCounter to increment by one
	movesCounter();
	starRating();
}

/*
If the two cards do not match, remove the cards
from the opened array and flip the cards back over by
removing the flip class.
*/
function noMatch() {
	/* After 700 miliseconds the two cards open will have
	the class of flip removed from the images parent element <li>*/
	setTimeout(function() {
		// Remove class flip on images parent element
		opened[0].parentElement.classList.remove("flip");
		opened[1].parentElement.classList.remove("flip");
		// Allow further mouse clicks on cards
		document.body.style.pointerEvents = "auto";
		// Remove the cards from opened array
		opened = [];
	}, 700);
	// Call movesCounter to increment by one
	movesCounter();
	starRating();
}

/*
Get stats on the time, how many moves, and star rating
for the end game and update the modal with these stats
*/
function AddStats() {
	// Access the modal content div
	const stats = document.querySelector(".modalgamecontent");
	// Create three different paragraphs
	for (let i = 1; i <= 3; i++) {
		// Create a new Paragraph
		const statsElement = document.createElement("p");
		// Add a class to the new Paragraph
		statsElement.classList.add("stats");
		// Add the new created <p> tag to the modal content
		stats.appendChild(statsElement);
	}
	// Select all p tags with the class of stats and update the content
	let p = stats.querySelectorAll("p.stats");
			// Set the new <p> to have the content of stats (time, moves and star rating)
		p[0].innerHTML = "Time to complete: " + minutes + " Minutes and " + seconds + " Seconds";
		p[1].innerHTML = "Moves Taken: " + moves;
		p[2].innerHTML = "Your Star Rating is: " + starCount + " out of 3";
}

/*
Display the modal on winning the game
Help with the modal from:
https://www.w3schools.com/howto/howto_css_modals.asp
*/
function displayModal() {
// Access the modal <span> element (x) that closes the modal
const modalClose = document.getElementsByClassName("close")[0];
	// When the game is won set modal to display block to show it
	modalgame.style.display= "block";

	// When the user clicks on <span> (x), close the modal
	modalClose.onclick = function() {
		modalgame.style.display = "none";
	};
// When the user clicks anywhere outside of the modal, close it
	window.onclick = function(event) {
		if (event.target == modalgame) {
			modalgame.style.display = "none";
		}
	};
}

/*
Check the length of the matched array and if there
are 8 pairs 16 cards all together then the game is won.
Stop the timer update the modal with stats and show the modal
*/
function winGame() {
	if (matched.length === 16) {
		stopTime();
		AddStats();
		displayModal();
	}
}

/*----------------------------------  
Main Event Listener
------------------------------------*/
/*
Event Listener if a card <li> is clicked
call flipCard()
*/
deck.addEventListener("click", function(evt) {
	if (evt.target.nodeName === "LI") {
		// To console if I was clicking the correct element 
		console.log(evt.target.nodeName + " Was clicked");
		// Start the timer after the first click of one card
	// Executes the timer() function
		if (timeStart === false) {
			timeStart = true; 
			timer();
		}
		// Call flipCard() function
		flipCard();
	}

	//Flip the card and display cards img
	function flipCard() {
		// When <li> is clicked add the class .flip to show img
		evt.target.classList.add("flip");
		// Call addToOpened() function
		addToOpened();
	}
	 
	//Add the fliped cards to the empty array of opened
	function addToOpened() {
		/* If the opened array has zero or one other img push another 
		img into the array so we can compare these two to be matched
		*/
		if (opened.length === 0 || opened.length === 1) {
			// Push that img to opened array
			opened.push(evt.target.firstElementChild);
		}
		// Call compareTwo() function
		compareTwo();
	}
}); //Event Listener

/*----------------------------------  
Restart Buttons
------------------------------------*/
/*
Event Listener to listen for a click on the reset
button, once clicked call resetEverything()
*/
reset.addEventListener('click', resetEverything);

/*
Event Listener to listen for a click on the play
again button, once clicked call resetEverything()
*/
playAgain.addEventListener('click',function() {
	modalgame.style.display = "none";
	resetEverything();
});







//pixie dust
let MAX_LIFE = 50;
let canvas = document.querySelector('canvas');
let input = document.querySelector('input');
let field = {}
let hasFocus = false;
let caret = document.createElement('span');
caret.style.position = 'absolute';
caret.style.left = 0;
caret.style.top = 0;
caret.style.margin = 0;
caret.style.width = 'auto';
caret.style.visibility = 'hidden';
document.body.appendChild(caret);

function reposition() {
	field = input.getBoundingClientRect();
}
window.onload = reposition;
window.onresize = reposition;
reposition();

input.onfocus = function() {hasFocus = true}
input.onblur = function() {hasFocus = false}

var keys = [8,9,13,16,17,18,27,32,33,34,35,36,37,38,39,40,46,91,93,112,113,114,115,116,117,118,119,120,121,122,123];
function spawnsCharacter(keyCode) {
	return keys.indexOf(keyCode) === -1;
}

function burst(intensity) {
	
	var behavior = [
		this.behavior.force(-.015,-.015),
		this.behavior.cohesion(50),
		this.behavior.move()
	];
	
	var size = 1.25;
	var force = .7;
	var lifeMin = 0;
	var progress = Math.min(field.width, caret.offsetWidth) / field.width;
	var offset = field.left + (field.width * progress);
	var rangeMin = Math.max(field.left, offset - 30);
	var rangeMax = Math.min(field.right, offset + 10);
	
	this.spray(intensity,function(){ return [
		null,null,
		Vector.create(
			Random.between(rangeMin + 10, rangeMax - 20),
			Random.between(field.top + 15, field.bottom - 15)
		),
		Vector.random(force),
		size + Math.random(),
		Random.between(lifeMin,0),behavior
	]});
	
	// top edge
	this.spray(intensity * .5,function(){ return [
		null,null,
		Vector.create(
			Random.between(rangeMin, rangeMax),
			field.top
		),
		Vector.random(force),
		size + Math.random(),
		Random.between(lifeMin,0),behavior
	]});
	
	// bottom edge
	this.spray(intensity * .5,function(){ return [
		null,null,
		Vector.create(
			Random.between(rangeMin, rangeMax),
			field.top + field.height
		),
		Vector.random(force),
		size + Math.random(),
		Random.between(lifeMin,0)
		,behavior
	]});
	
	// left edge
	if (input.value.length === 1) {
		
		this.spray(intensity * 2,function(){ return [
			null,null,
			Vector.create(
				field.left + (Math.random() * 20),
				Random.between(field.top,field.bottom)
			),
			Vector.random(force),
			size + Math.random(),
			Random.between(lifeMin,0),behavior
		]});
	}
	
	// right edge
	if (rangeMax == field.right) {

		this.spray(intensity * 2,function(){ return [
			null,null,
			Vector.create(
				field.right,
				Random.between(field.top,field.bottom)
			),
			Vector.random(force),
			size + Math.random(),
			Random.between(lifeMin,0),behavior
		]});

	}
	
}




simulate(
		'2d', {
				init: function() {
					
				},
				tick: function(particles) {

					if (!particles){ return; }

					particles.forEach(function(p){

						if (p.life > MAX_LIFE) {
							this.destroy(p);
						}
						
					});
					
				},
				beforePaint: function() {
						this.clear();
				},
				paint: function(particle) {
					
					let p = particle.position;
					let s = particle.size;
					let o = 1 - (particle.life / MAX_LIFE);
					
					this.paint.circle(p.x, p.y, s, 'rgba(255,255,255,' + o +')');
					this.paint.circle(p.x, p.y, s + 1.5, 'rgba(231,244,255,' + (o * .25) + ')');
					
					// extra
					let w = 2;
					let wh = w * .5;
					let h = 35;
					let hh = h * .5;
					this.context.rect(p.x -wh, p.y - hh, w, h);
					this.context.fillStyle = 'rgba(231,244,255,' + (o * .025) + ')';
					this.context.fill();
					this.context.closePath();
					
				},
				afterPaint: function() {
						// nothing
				},
				action: function(e) {
					
					if (!spawnsCharacter(e.keyCode)) {
						return;
					}
					
					caret.textContent = input.value;
					
					burst.call(this,12);
					
					input.classList.add('keyup');
					setTimeout(function(){input.classList.remove('keyup')},100);
					
				}
		}
);


















PI_2 = Math.PI / 2;
PI_180 = Math.PI / 180;

//random
var Random = {
		between: function(min, max) {
				return min + (Math.random() * (max - min));
		}
}

//2d vector class
function Vector(x, y) {
		this._x = x || 0;
		this._y = y || 0;
}

Vector.create = function(x, y) {
		return new Vector(x, y);
};

Vector.add = function(a, b) {
		return new Vector(a.x + b.x, a.y + b.y);
};

Vector.subtract = function(a, b) {
		return new Vector(a.x - b.x, a.y - b.y);
};

Vector.random = function(range) {
		let v = new Vector();
		v.randomize(range);
		return v;
};

Vector.distanceSquared = function(a, b) {
		let dx = a.x - b.x;
		let dy = a.y - b.y;
		return dx * dx + dy * dy;
};

Vector.distance = function(a, b) {
		let dx = a.x - b.x;
		let dy = a.y - b.y;
		return Math.sqrt(dx * dx + dy * dy);
};

Vector.prototype = {
		get x() {
				return this._x;
		},
		get y() {
				return this._y;
		},
		set x(value) {
				this._x = value;
		},
		set y(value) {
				this._y = value;
		},
		get magnitudeSquared() {
				return this._x * this._x + this._y * this._y;
		},
		get magnitude() {
				return Math.sqrt(this.magnitudeSquared);
		},
		get angle() {
				return Math.atan2(this._y, this._x) * 180 / Math.PI;
		},
		clone: function() {
				return new Vector(this._x, this._y);
		},
		add: function(v) {
				this._x += v.x;
				this._y += v.y;
		},
		subtract: function(v) {
				this._x -= v.x;
				this._y -= v.y;
		},
		multiply: function(value) {
				this._x *= value;
				this._y *= value;
		},
		divide: function(value) {
				this._x /= value;
				this._y /= value;
		},
		normalize: function() {
				var magnitude = this.magnitude;
				if (magnitude > 0) {
						this.divide(magnitude);
				}
		},
		limit: function(treshold) {
				if (this.magnitude > treshold) {
						this.normalize();
						this.multiply(treshold);
				}
		},
		randomize: function(amount) {
				amount = amount || 1;
				this._x = amount * 2 * (-.5 + Math.random());
				this._y = amount * 2 * (-.5 + Math.random());
		},
		rotate: function(degrees) {
				var magnitude = this.magnitude;
				var angle = ((Math.atan2(this._x, this._y) * PI_HALF) + degrees) * PI_180;
				this._x = magnitude * Math.cos(angle);
				this._y = magnitude * Math.sin(angle);
		},
		flip: function() {
				var temp = this._y;
				this._y = this._x;
				this._x = temp;
		},
		invert: function() {
				this._x = -this._x;
				this._y = -this._y;
		},
		toString: function() {
				return this._x + ', ' + this._y;
		}
}

//practicle class
function Particle(id, group, position, velocity, size, life, behavior) {

		this._id = id || 'default';
		this._group = group || 'default';

		this._position = position || new Vector();
		this._velocity = velocity || new Vector();
		this._size = size || 1;
		this._life = Math.round(life || 0);

		this._behavior = behavior || [];

}

Particle.prototype = {
		get id() {
				return this._id;
		},
		get group() {
				return this._group;
		},
		get life() {
				return this._life;
		},
		get size() {
				return this._size;
		},
		set size(size) {
				this._size = size;
		},
		get position() {
				return this._position;
		},
		get velocity() {
				return this._velocity;
		},
		update: function(stage) {

				this._life++;

				var i = 0;
				var l = this._behavior.length;

				for (; i < l; i++) {
						this._behavior[i].call(stage, this);
				}

		},
		toString: function() {
				return 'Particle(' + this._id + ') ' + this._life + ' pos: ' + this._position + ' vec: ' + this._velocity;
		}
}

// setup DOM
function simulate(dimensions, options) {

		
		let particles = [];
		var destroyed = [];
		var update = update || function() {};
		var stage = stage || function() {};
		var canvas;
		var context;

		if (!options) {
				console.error('"options" object must be defined');
				return;
		}

		if (!options.init) {
				console.error('"init" function must be defined');
				return;
		}

		if (!options.paint) {
				console.error('"paint" function must be defined');
				return;
		}

		if (!options.tick) {
				options.tick = function() {};
		}

		if (!options.beforePaint) {
				options.beforePaint = function() {};
		}

		if (!options.afterPaint) {
				options.afterPaint = function() {};
		}

		if (!options.action) {
				options.action = function() {};
		}

		if (document.readyState === 'interactive') {
				setup();
		} else {
				document.addEventListener('DOMContentLoaded', setup);
		}

		// resizes canvas to fit window dimensions
		function fitCanvas() {
				canvas.width = window.innerWidth;
				canvas.height = window.innerHeight;
		}

		// create canvas for drawing
		function setup() {

				// create
				canvas = document.createElement('canvas');
				document.body.appendChild(canvas);

				// correct canvas size on window resize
				window.addEventListener('resize', fitCanvas);

				// go
				go();
		}

		// canvas has been attached, let's go!
		function go() {

				// set initial canvas size
				fitCanvas();

				// get context for drawing
				context = canvas.getContext(dimensions);

				// simulation update loop
				function act() {

						// update particle states
						let i = 0;
						let l = particles.length;
						let p;
						for (; i < l; i++) {
								particles[i].update(this);
						}

						// clean destroyed particles
						while (p = destroyed.pop()) {

								do {
										
										// has not been found in destroyed array?
										if (p !== particles[i]) {
												continue;
										}
									
										// remove particle
										particles.splice(i, 1);

								} while (i-- >= 0)
						}
						
						// repaint context
						options.beforePaint.call(this);

						// repaint particles
						i = 0;
						l = particles.length;
						for (; i < l; i++) {
								options.paint.call(this, particles[i]);
						}

						// after particles have been painted
						options.afterPaint.call(this);
				}

				function tick() {

						// call update method, this allows for inserting particles later on
						options.tick.call(this, particles);

						// update particles here
						act();

						// on to the next frame
						window.requestAnimationFrame(tick);

				}

				
				function clear() {
						context.clearRect(0, 0, canvas.width, canvas.height);
				}

				function destroy(particle) {
						destroyed.push(particle);
				}

				function add(id, group, position, velocity, size, life, behavior) {
						particles.push(new Particle(id, group, position, velocity, size, life, behavior));
				}

				function spray(amount, config) {
						let i = 0;
						for (; i < amount; i++) {
								add.apply(this, config());
						}
				}

				function debug(particle) {
						this.paint.circle(
								particle.position.x,
								particle.position.y,
								particle.size,
								'rgba(255,0,0,.75)'
						);
						context.beginPath();
						context.moveTo(particle.position.x, particle.position.y);
						context.lineTo(particle.position.x + (particle.velocity.x * 10), particle.position.y + (particle.velocity.y * 10));
						context.strokeStyle = 'rgba(255,0,0,.1)';
						context.stroke();
						context.closePath();
				};

				this.clear = clear;
				this.destroy = destroy;
				this.add = add;
				this.spray = spray;
				this.debug = debug;

				this.paint = {
						circle: function(x, y, size, color) {
								context.beginPath();
								context.arc(x, y, size, 0, 2 * Math.PI, false);
								context.fillStyle = color;
								context.fill();
						},
						square: function(x, y, size, color) {
								context.beginPath();
								context.rect(x - (size * .5), y - (size * .5), size, size);
								context.fillStyle = color;
								context.fill();
						}
				}

				this.behavior = {
						cohesion: function(range, speed) {
								range = Math.pow(range || 100, 2);
								speed = speed || .001;
								return function(particle) {

										var center = new Vector();
										var i = 0;
										var l = particles.length;
										var count = 0;

										if (l <= 1) {
												return;
										}

										for (; i < l; i++) {

												// don't use self in group
												if (particles[i] === particle || Vector.distanceSquared(particles[i].position, particle.position) > range) {
														continue;
												}

												center.add(Vector.subtract(particles[i].position, particle.position));
												count++;
										}

										if (count > 0) {

												center.divide(count);

												center.normalize();
												center.multiply(particle.velocity.magnitude);

												center.multiply(.05);
										}

										particle.velocity.add(center);

								}
						},
						separation: function(distance) {

								var distance = Math.pow(distance || 25, 2);

								return function(particle) {

										var heading = new Vector();
										var i = 0;
										var l = particles.length;
										var count = 0;
										var diff;

										if (l <= 1) {
												return;
										}

										for (; i < l; i++) {

												// don't use self in group
												if (particles[i] === particle || Vector.distanceSquared(particles[i].position, particle.position) > distance) {
														continue;
												}

												// stay away from neighbours
												diff = Vector.subtract(particle.position, particles[i].position);
												diff.normalize();

												heading.add(diff);
												count++;
										}

										if (count > 0) {

												// get average
												heading.divide(count);

												// make same length as current velocity (so particle won't speed up)
												heading.normalize();
												heading.multiply(particle.velocity.magnitude);

												// limit force to make particle movement smoother
												heading.limit(.1);
										}

										particle.velocity.add(heading);

								}
						},
						alignment: function(range) {
								range = Math.pow(range || 100, 2);
								return function(particle) {

										let i = 0;
										let l = particles.length;
										let count = 0;
										let heading = new Vector();

										if (l <= 1) {
												return;
										}

										for (; i < l; i++) {

												// don't use self in group also don't align when out of range
												if (particles[i] === particle || Vector.distanceSquared(particles[i].position, particle.position) > range) {
														continue;
												}

												heading.add(particles[i].velocity);
												count++;
										}

										if (count > 0) {

												heading.divide(count);
												heading.normalize();
												heading.multiply(particle.velocity.magnitude);

												// limit
												heading.multiply(.1);

										}

										particle.velocity.add(heading);

								}
						},
						move: function() {
								return function(particle) {
										particle.position.add(particle.velocity);

										// handle collisions?

								}
						},
						eat: function(food) {
								food = food || [];
								return function(particle) {

										let i = 0;
										let l = particles.length;
										let prey;

										for (; i < l; i++) {

												prey = particles[i];

												// can't eat itself, also, needs to be tasty
												if (prey === particle || food.indexOf(prey.group) === -1) {
														continue;
												}

												// calculate force vector
												if (Vector.distanceSquared(particle.position, neighbour.position) < 2 && particle.size >= neighbour.size) {
														particle.size += neighbour.size;
														destroy(neighbour);
												}

										}
								}
						},
						force: function(x, y) {
								return function(particle) {
										particle.velocity.x += x;
										particle.velocity.y += y;
								}
						},
						limit: function(treshold) {
								return function(particle) {
										particle.velocity.limit(treshold);
								}
						},
						attract: function(forceMultiplier, groups) {
								forceMultiplier = forceMultiplier || 1;
								groups = groups || [];
								return function(particle) {

										// attract other particles
										let totalForce = new Vector(0, 0);
										let force = new Vector(0, 0);
										let i = 0;
										let l = particles.length;
										let distance;
										let pull;
										let attractor;
										let grouping = groups.length;

										for (; i < l; i++) {

												attractor = particles[i];

												// can't be attracted by itself or mismatched groups
												if (attractor === particle || (grouping && groups.indexOf(attractor.group) === -1)) {
														continue;
												}

												// calculate force vector
												force.x = attractor.position.x - particle.position.x;
												force.y = attractor.position.y - particle.position.y;
												distance = force.magnitude;
												force.normalize();

												// the bigger the attractor the more force
												force.multiply(attractor.size / distance);

												totalForce.add(force);
										}

										totalForce.multiply(forceMultiplier);

										particle.velocity.add(totalForce);
								}
						},
						wrap: function(margin) {
								return function(particle) {

										// move around when particle reaches edge of screen
										let position = particle.position;
										let radius = particle.size * .5;

										if (position.x + radius > canvas.width + margin) {
												position.x = radius;
										}

										if (position.y + radius > canvas.height + margin) {
												position.y = radius;
										}

										if (position.x - radius < -margin) {
												position.x = canvas.width - radius;
										}

										if (position.y - radius < -margin) {
												position.y = canvas.height - radius;
										}

								}
						},
						reflect: function() {

								return function(particle) {

										// bounce from edges
										let position = particle.position;
										let velocity = particle.velocity;
										let radius = particle.size * .5;

										if (position.x + radius > canvas.width) {
												velocity.x = -velocity.x;
										}

										if (position.y + radius > canvas.height) {
												velocity.y = -velocity.y;
										}

										if (position.x - radius < 0) {
												velocity.x = -velocity.x;
										}

										if (position.y - radius < 0) {
												velocity.y = -velocity.y;
										}
								}

						},
						edge: function(action) {
								return function(particle) {

										let position = particle.position;
										let velocity = particle.velocity;
										let radius = particle.size * .5;

										if (position.x + radius > canvas.width) {
												action(particle);
										}

										if (position.y + radius > canvas.height) {
												action(particle);
										}

										if (position.x - radius < 0) {
												action(particle);
										}

										if (position.y - radius < 0) {
												action(particle);
										}
								}
						}
				}

			
				Object.defineProperties(this, {
						'particles': {
								get: function() {
										return particles;
								}
						},
						'width': {
								get: function() {
										return canvas.width;
								}
						},
						'height': {
								get: function() {
										return canvas.height;
								}
						},
						'context': {
								get: function() {
										return context;
								}
						}
				});

				
				options.init.call(this)

				
				tick();

				let self = this;
				document.addEventListener('keyup', function(e) {
						options.action.call(self, e);
				});

		}

};
        

        </script>
        
    </body>
    </html>